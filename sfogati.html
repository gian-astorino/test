import { useRef, useState, useEffect } from "react";

export default function SpriteLauncher() {
  const canvasRef = useRef(null);
  const positionRef = useRef({ x: 0, y: 0 });
  const velocityRef = useRef({ x: 0, y: 0 });
  const hitsRef = useRef(-1);
  const [hits, setHits] = useState(-1);
  const [isDragging, setIsDragging] = useState(false);
  const [startDrag, setStartDrag] = useState(null);
  const audioCtxRef = useRef(null);
  const angleRef = useRef(0);
  const angularVelocityRef = useRef(0);
  const spriteRef = useRef(null);
  const spriteAltRef = useRef(null);
  const showAltSpriteRef = useRef(false);
  const spriteSizeRef = useRef({ width: 100, height: 100 });
  const scale = 0.3;

  const playSound = () => {
    if (!audioCtxRef.current) {
      audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
    }
    const audioCtx = audioCtxRef.current;
    const oscillator = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(300 + Math.random() * 100, audioCtx.currentTime);

    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.03, now + 0.01);
    gain.gain.linearRampToValueAtTime(0, now + 0.08);

    oscillator.connect(gain);
    gain.connect(audioCtx.destination);
    oscillator.start(now);
    oscillator.stop(now + 0.1);
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");

    const img = new Image();
    img.src = "https://github.com/gian-astorino/test/blob/main/Sprite%20Ouch%201.png?raw=true";
    img.onload = () => {
      spriteRef.current = img;
      spriteSizeRef.current = { width: img.width * scale, height: img.height * scale };
      positionRef.current = {
        x: window.innerWidth / 2 - spriteSizeRef.current.width / 2,
        y: window.innerHeight - spriteSizeRef.current.height - 1
      };
    };

    const imgAlt = new Image();
    imgAlt.src = "https://github.com/gian-astorino/test/blob/main/Sprite%20Ouch%202.png?raw=true";
    imgAlt.onload = () => {
      spriteAltRef.current = imgAlt;
    };

    const gravity = 0.6;
    const airFriction = 0.995;
    const groundFriction = 0.85;
    const wallBounce = -0.8;
    const floorBounce = -0.4;
    const angularFriction = 0.92;
    let lastHit = { top: false, bottom: false, left: false, right: false };

    function resizeCanvas() {
      const dpi = window.devicePixelRatio || 1;
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      canvas.width = vw * dpi;
      canvas.height = vh * dpi;
      canvas.style.width = `${vw}px`;
      canvas.style.height = `${vh}px`;

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpi, dpi);
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const render = () => {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, "#4393E6");
      gradient.addColorStop(1, "#70C4EB");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const pos = positionRef.current;
      const vel = velocityRef.current;

      if (
        Math.abs(angularVelocityRef.current) > 0.001 &&
        (Math.abs(velocityRef.current.x) > 0.5 || Math.abs(velocityRef.current.y) > 0.5)
      ) {
        angleRef.current += angularVelocityRef.current;
      } else {
        angularVelocityRef.current = 0;
      }
      angularVelocityRef.current *= angularFriction;

      const { width, height } = spriteSizeRef.current;

      ctx.save();
      ctx.translate(pos.x + width / 2, pos.y + height / 2);
      ctx.rotate(angleRef.current);

      const sprite = showAltSpriteRef.current && spriteAltRef.current ? spriteAltRef.current : spriteRef.current;
      if (sprite) {
        ctx.drawImage(sprite, -width / 2, -height / 2, width, height);
      }
      ctx.restore();

      ctx.fillStyle = "#000";
      ctx.font = "20px 'Varela Round', sans-serif";
      ctx.fillText(`Hits: ${hitsRef.current}`, 20, 30);

      const onGround = pos.y + height >= window.innerHeight;
      if (onGround) {
        vel.x *= groundFriction;
        angularVelocityRef.current *= 0.85;
      } else {
        vel.x *= airFriction;
      }

      vel.y += gravity;
      pos.x += vel.x;
      pos.y += vel.y;

      const velocityThreshold = 0.5;

      const registerHit = (side, rotationBoost) => {
        hitsRef.current++;
        showAltSpriteRef.current = true;
        setTimeout(() => { showAltSpriteRef.current = false; }, 500);
        setHits(hitsRef.current);
        angularVelocityRef.current += rotationBoost;
        playSound();
        lastHit[side] = true;
      };

      if (pos.x < 0) {
        pos.x = 0;
        vel.x *= wallBounce;
        if (!lastHit.left && Math.abs(vel.x) > velocityThreshold) {
          registerHit("left", 0.3);
        }
      } else {
        lastHit.left = false;
      }

      if (pos.x + width > window.innerWidth) {
        pos.x = window.innerWidth - width;
        vel.x *= wallBounce;
        if (!lastHit.right && Math.abs(vel.x) > velocityThreshold) {
          registerHit("right", -0.3);
        }
      } else {
        lastHit.right = false;
      }

      if (pos.y < 0) {
        pos.y = 0;
        vel.y *= wallBounce;
        if (!lastHit.top && Math.abs(vel.y) > velocityThreshold) {
          registerHit("top", 0.2);
        }
      } else {
        lastHit.top = false;
      }

      if (pos.y + height > window.innerHeight) {
        pos.y = window.innerHeight - height;
        vel.y *= floorBounce;
        if (!lastHit.bottom && Math.abs(vel.y) > velocityThreshold) {
          registerHit("bottom", -0.2);
        }
      } else {
        lastHit.bottom = false;
      }

      requestAnimationFrame(render);
    };

    render();

    return () => {
      window.removeEventListener("resize", resizeCanvas);
    };
  }, []);

  const handleMouseDown = (e) => {
    const x = e.clientX;
    const y = e.clientY;
    positionRef.current = { x, y };
    velocityRef.current = { x: 0, y: 0 };
    angularVelocityRef.current = 0;
    setIsDragging(true);
    setStartDrag({ x, y });
  };

  const handleMouseUp = (e) => {
    if (isDragging && startDrag) {
      const endDrag = { x: e.clientX, y: e.clientY };
      const dx = endDrag.x - startDrag.x;
      const dy = endDrag.y - startDrag.y;
      velocityRef.current = { x: dx / 8, y: dy / 8 };
      angularVelocityRef.current = dx / 100;
    }
    setIsDragging(false);
    setStartDrag(null);
  };

  return (
    <canvas
      ref={canvasRef}
      className="fixed top-0 left-0 w-full h-full"
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      onTouchStart={(e) => handleMouseDown(e.touches[0])}
      onTouchEnd={(e) => handleMouseUp(e.changedTouches[0])}
      ref={canvasRef}
      className="fixed top-0 left-0 w-full h-full"
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
    />
  );
}
